let AST_Type: i32 = 0;
let AST_NumberLiteral: i32 = 1;
let AST_StringLiteral: i32 = 2;
let AST_BoolLiteral: i32 = 3;
let AST_NullLiteral: i32 = 4;
let AST_Variable: i32 = 5;
let AST_BinaryOp: i32 = 6;
let AST_UnaryOp: i32 = 7;
let AST_Assignment: i32 = 8;
let AST_ArrayAccess: i32 = 9;
let AST_FieldAccess: i32 = 10;
let AST_FunctionCall: i32 = 11;
let AST_TypeCast: i32 = 12;
let AST_ArrayLiteral: i32 = 13;
let AST_ObjectLiteral: i32 = 14;
let AST_NameType: i32 = 15;
let AST_VarDecl: i32 = 16;
let AST_ExprStmt: i32 = 17;
let AST_Block: i32 = 18;
let AST_IfStmt: i32 = 19;
let AST_WhileStmt: i32 = 20;
let AST_ReturnStmt: i32 = 21;
let AST_FunctionDecl: i32 = 22;
let AST_InterfaceDecl: i32 = 23;
let AST_Program: i32 = 24;
let AST_KeyVal: i32 = 25;
let AST_Import: i32 = 26;
let AST_Export: i32 = 27;

interface ASTNode {
  type: i32;
  name: String;
  arrayDepth: i32;
  valueNum: f64;
  valueStr: String;
  valueBool: boolean;
  op: String;
  cond: ASTNode;
  left: ASTNode;
  right: ASTNode;
  args: ASTNode[];
  imports: String[];
  injectedName: String;
  injectedType: ASTNode;
}

function Type_new(n: String, depth: i32): ASTNode {
  let type: ASTNode = { type: AST_Type, name: n, arrayDepth: depth };
  return type;
}
function NumberLiteral_new(value: f64): ASTNode {
  let num: ASTNode = { type: AST_NumberLiteral, valueNum: value };
  return num;
}
function StringLiteral_new(value: String): ASTNode {
  let str: ASTNode = { type: AST_StringLiteral, valueStr: value };
  return str;
}
function BoolLiteral_new(value: boolean): ASTNode {
  let boolLit: ASTNode = { type: AST_BoolLiteral, valueBool: value };
  return boolLit;
}
function NullLiteral_new(): ASTNode {
  let nullLit: ASTNode = { type: AST_NullLiteral };
  return nullLit;
}
function Variable_new(name: String): ASTNode {
  let variable: ASTNode = { type: AST_Variable, name: name };
  return variable;
}
function BinaryOp_new(op: String, left: ASTNode, right: ASTNode): ASTNode {
  let binaryOp: ASTNode = { type: AST_BinaryOp, op: op, left: left, right: right };
  return binaryOp;
}
function UnaryOp_new(op: String, operand: ASTNode, prefix: boolean): ASTNode {
  if (prefix) {
    let unaryOp: ASTNode = { type: AST_UnaryOp, op: op, right: operand };
    return unaryOp;
  } else {
    let unaryOp: ASTNode = { type: AST_UnaryOp, op: op, left: operand };
    return unaryOp;
  }
}
function Assignment_new(l: ASTNode, r: ASTNode): ASTNode {
  let assignment: ASTNode = { type: AST_Assignment, left: l, right: r };
  return assignment;
}
function ArrayAccess_new(a: ASTNode, i: ASTNode): ASTNode {
  let arrayAccess: ASTNode = { type: AST_ArrayAccess, left: a, right: i };
  return arrayAccess;
}
function FieldAccess_new(o: ASTNode, f: String): ASTNode {
  let fieldAccess: ASTNode = { type: AST_FieldAccess, left: o, name: f };
  return fieldAccess;
}
function FunctionCall_new(f: ASTNode, args: ASTNode[]): ASTNode {
  let functionCall: ASTNode = { type: AST_FunctionCall, left: f, args: args };
  return functionCall;
}
function TypeCast_new(e: ASTNode, t: ASTNode): ASTNode {
  let typeCast: ASTNode = { type: AST_TypeCast, left: e, right: t };
  return typeCast;
}
function ArrayLiteral_new(elements: ASTNode[]): ASTNode {
  let arrayLiteral: ASTNode = { type: AST_ArrayLiteral, args: elements };
  return arrayLiteral;
}
function ObjectLiteral_new(properties: ASTNode[]): ASTNode {
  let objectLiteral: ASTNode = { type: AST_ObjectLiteral, args: properties };
  return objectLiteral;
}
function NameType_new(n: String, t: ASTNode): ASTNode {
  let nameType: ASTNode = { type: AST_NameType, name: n, right: t };
  return nameType;
}
function KeyVal_new(k: String, v: ASTNode): ASTNode {
  let keyVal: ASTNode = { type: AST_KeyVal, name: k, right: v };
  return keyVal;
}
function VarDecl_new(n: String, t: ASTNode, i: ASTNode): ASTNode {
  let varDecl: ASTNode = { type: AST_VarDecl, name: n, left: t, right: i };
  return varDecl;
}
function ExprStmt_new(e: ASTNode): ASTNode {
  let exprStmt: ASTNode = { type: AST_ExprStmt, left: e };
  return exprStmt;
}
function Block_new(stmts: ASTNode[]): ASTNode {
  let block: ASTNode = { type: AST_Block, args: stmts };
  return block;
}
function IfStmt_new(c: ASTNode, t: ASTNode, e: ASTNode): ASTNode {
  let ifStmt: ASTNode = { type: AST_IfStmt, cond: c, left: t, right: e };
  return ifStmt;
}
function WhileStmt_new(c: ASTNode, b: ASTNode): ASTNode {
  let whileStmt: ASTNode = { type: AST_WhileStmt, cond: c, left: b };
  return whileStmt;
}
function ReturnStmt_new(v: ASTNode): ASTNode {
  let returnStmt: ASTNode = { type: AST_ReturnStmt, left: v };
  return returnStmt;
}
function FunctionDecl_new(n: String, p: ASTNode[], rt: ASTNode, b: ASTNode): ASTNode {
  let functionDecl: ASTNode = { type: AST_FunctionDecl, name: n, args: p, left: rt, right: b };
  return functionDecl;
}
function InterfaceDecl_new(n: String, m: ASTNode[]): ASTNode {
  let interfaceDecl: ASTNode = { type: AST_InterfaceDecl, name: n, args: m };
  return interfaceDecl;
}
function Program_new(stmts: ASTNode[]): ASTNode {
  let program: ASTNode = { type: AST_Program, args: stmts };
  return program;
}
function Import_new(m: String, s: String[]): ASTNode {
  let imprt: ASTNode = { type: AST_Import, imports: s, name: m };
  return imprt;
}
function Export_new(s: ASTNode): ASTNode {
  let exportStmt: ASTNode = { type: AST_Export, right: s };
  return exportStmt;
}

function ASTNode_toString(node: ASTNode): String {
  if (node.type == AST_Type) {
    let result: String = node.name;
    let i: i32 = 0;
    while (i < node.arrayDepth) {
      result = result.add("[]");
      ++i;
    }
    return result;
  }
  if (node.type == AST_NumberLiteral) {
    if (node.valueNum == int(node.valueNum)) return StringFrom(int(node.valueNum));
    return StringFrom(node.valueNum);
  }
  if (node.type == AST_StringLiteral) {
    return node.valueStr;
  }
  if (node.type == AST_BoolLiteral) {
    if (node.valueBool) return "true";
    return "false";
  }
  if (node.type == AST_NullLiteral) {
    return "null";
  }
  if (node.type == AST_Variable) {
    return node.name;
  }
  if (node.type == AST_BinaryOp) {
    return "(".add(ASTNode_toString(node.left)).add(" ").add(node.op).add(" ").add(ASTNode_toString(node.right)).add(")");
  }
  if (node.type == AST_UnaryOp) {
    if (node.right) return "(".add(node.op).add(ASTNode_toString(node.right)).add(")");
    return "(".add(ASTNode_toString(node.left)).add(node.op).add(")");
  }
  if (node.type == AST_Assignment) {
    return ASTNode_toString(node.left).add(" = ").add(ASTNode_toString(node.right));
  }
  if (node.type == AST_ArrayAccess) {
    return ASTNode_toString(node.left).add("[").add(ASTNode_toString(node.right)).add("]");
  }
  if (node.type == AST_FieldAccess) {
    return ASTNode_toString(node.left).add(".").add(node.name);
  }
  if (node.type == AST_FunctionCall) {
    let result: String = ASTNode_toString(node.left).add("(");
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(ASTNode_toString(node.args[i]));
      ++i;
    }
    return result.add(")");
  }
  if (node.type == AST_TypeCast) {
    return "(".add(ASTNode_toString(node.left)).add(" as ").add(ASTNode_toString(node.right)).add(")");
  }
  if (node.type == AST_ArrayLiteral) {
    let result: String = "[";
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(ASTNode_toString(node.args[i]));
      ++i;
    }
    return result.add("]");
  }
  if (node.type == AST_ObjectLiteral) {
    let result: String = "{";
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(ASTNode_toString(node.args[i]));
      ++i;
    }
    return result.add("}");
  }
  if (node.type == AST_NameType || node.type == AST_KeyVal) {
    return node.name.add(": ").add(ASTNode_toString(node.right));
  }
  if (node.type == AST_VarDecl) {
    return "let ".add(node.name).add(": ").add(ASTNode_toString(node.left)).add(" = ").add(ASTNode_toString(node.right)).add(";");
  }
  if (node.type == AST_ExprStmt) {
    return ASTNode_toString(node.left).add(";");
  }
  if (node.type == AST_Block) {
    let result: String = "{\n";
    let i: i32 = 0;
    while (i < node.args.length()) {
      result = result.add("  ").add(ASTNode_toString(node.args[i])).add("\n");
      ++i;
    }
    return result.add("}");
  }
  if (node.type == AST_IfStmt) {
    let result: String = "if (".add(ASTNode_toString(node.cond)).add(")").add(ASTNode_toString(node.left));
    if (node.right) result = result.add(" else ").add(ASTNode_toString(node.right));
    return result;
  }
  if (node.type == AST_WhileStmt) {
    return "while (".add(ASTNode_toString(node.cond)).add(")").add(ASTNode_toString(node.left));
  }
  if (node.type == AST_ReturnStmt) {
    return "return ".add(ASTNode_toString(node.left)).add(";");
  }
  if (node.type == AST_FunctionDecl) {
    let result: String = "function ".add(node.name).add("(");
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(ASTNode_toString(node.args[i]));
      ++i;
    }
    result = result.add("): ").add(ASTNode_toString(node.left)).add(" ").add(ASTNode_toString(node.right));
    return result;
  }
  if (node.type == AST_InterfaceDecl) {
    let result: String = "interface ".add(node.name).add(" {\n");
    let i: i32 = 0;
    while (i < node.args.length()) {
      result = result.add("  ").add(ASTNode_toString(node.args[i])).add(";\n");
      ++i;
    }
    return result.add("}");
  }
  if (node.type == AST_Program) {
    let result: String = "";
    let i: i32 = 0;
    while (i < node.args.length()) {
      result = result.add(ASTNode_toString(node.args[i])).add("\n");
      ++i;
    }
    return result;
  }
  if (node.type == AST_Import) {
    let result: String = "import {";
    let i: i32 = 0;
    while (i < node.imports.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(node.imports[i]);
      ++i;
    }
    return result.add("} from ").add(node.name).add(";");
  }
  if (node.type == AST_Export) {
    return "export ".add(ASTNode_toString(node.right));
  }

  return "UNKNOWN!!!";
}
function Type_isValType(name: String): boolean {
  return name === "i8" || name === "i16" || name === "i32" || name === "i64" || name === "i128" || name === "u8" || name === "u16" || name === "u32" || name === "u64" || name === "u128" || name === "f32" || name === "f64" || name === "f128" || name === "void";
}
function InterfaceDecl_declgen(node: ASTNode): String {
  return "struct ".add(node.name).add(";");
}
function FunctionDecl_declgen(node: ASTNode): String {
  let result: String = ASTNode_codegen(node.left).add(" ").add(node.name).add("(");
  let i: i32 = 0;
  while (i < node.args.length()) {
    if (i > 0) result = result.add(", ");
    result = result.add(ASTNode_codegen(node.args[i]));
    ++i;
  }
  return result.add(");");
}
function ASTNode_codegen(node: ASTNode): String {
  if (node.type == AST_Type) {
    if (node.name === "boolean") return "bool";

    let name: String = null;
    if (Type_isValType(node.name)) name = node.name;
    else name = "AutoRef<".add(node.name).add(">");

    if (node.arrayDepth > 0) {
      let i: i32 = 0;
      while (i < node.arrayDepth) {
        name = "AutoRef<Array<".add(name).add(">>");
        ++i;
      }
    }
    return name;
  }
  if (node.type == AST_NumberLiteral) {
    if (node.valueNum == int(node.valueNum)) return StringFrom(int(node.valueNum));
    return StringFrom(node.valueNum).add("f");
  }
  if (node.type == AST_StringLiteral) {
    return "newString(".add(node.valueStr).add(")");
  }
  if (node.type == AST_BoolLiteral) {
    if (node.valueBool) return "true";
    return "false";
  }
  if (node.type == AST_NullLiteral) {
    return "nullptr";
  }
  if (node.type == AST_Variable) {
    return node.name;
  }
  if (node.type == AST_BinaryOp) {
    if (node.op === "**")
      return "std::pow(".add(ASTNode_codegen(node.left)).add(", ").add(ASTNode_codegen(node.right)).add(")");
    if (node.op === "===")
      return "(*(".add(ASTNode_codegen(node.left)).add(") == (").add(ASTNode_codegen(node.right)).add("))");
    if (node.op === "!==")
      return "(*(".add(ASTNode_codegen(node.left)).add(") != (").add(ASTNode_codegen(node.right)).add("))");
    return "(".add(ASTNode_codegen(node.left)).add(" ").add(node.op).add(" ").add(ASTNode_codegen(node.right)).add(")");
  }
  if (node.type == AST_UnaryOp) {
    if (node.right) return "(".add(node.op).add(ASTNode_codegen(node.right)).add(")");
    return "(".add(ASTNode_codegen(node.left)).add(node.op).add(")");
  }
  if (node.type == AST_Assignment) {
    return ASTNode_codegen(node.left).add(" = ").add(ASTNode_codegen(node.right));
  }
  if (node.type == AST_ArrayAccess) {
    return ASTNode_codegen(node.left).add("->at(").add(ASTNode_codegen(node.right)).add(")");
  }
  if (node.type == AST_FieldAccess) {
    return ASTNode_codegen(node.left).add("->").add(node.name);
  }
  if (node.type == AST_FunctionCall) {
    let result: String = ASTNode_codegen(node.left).add("(");
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(ASTNode_codegen(node.args[i]));
      ++i;
    }
    return result.add(")");
  }
  if (node.type == AST_TypeCast) {
    return "(".add(ASTNode_codegen(node.left)).add(".as<").add(ASTNode_codegen(node.right)).add(">())");
  }
  if (node.type == AST_ArrayLiteral) {
    if (node.args.length() > 0) {
      let result: String = "newArray(std::initializer_list(";
      let i: i32 = 0;
      while (i < node.args.length()) {
        if (i > 0) result = result.add(", ");
        result = result.add(ASTNode_codegen(node.args[i]));
        ++i;
      }
      return result.add("))");
    }
    return ASTNode_codegen(node.injectedType).add("::make()");
  }
  if (node.type == AST_ObjectLiteral) {
    let result: String = ASTNode_codegen(node.injectedType).add("::make(); ");
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add("; ");
      node.args[i].injectedName = node.injectedName;
      result = result.add(ASTNode_codegen(node.args[i]));
      ++i;
    }
    return result;
  }
  if (node.type == AST_NameType) {
    return ASTNode_codegen(node.right).add(" ").add(node.name);
  }
  if (node.type == AST_KeyVal) {
    return node.injectedName.add("->").add(node.name).add(" = ").add(ASTNode_codegen(node.right));
  }
  if (node.type == AST_VarDecl) {
    node.right.injectedName = node.name;
    node.right.injectedType = node.left;

    return ASTNode_codegen(node.left).add(" ").add(node.name).add(" = ").add(ASTNode_codegen(node.right)).add(";");
  }
  if (node.type == AST_ExprStmt) {
    return ASTNode_codegen(node.left).add(";");
  }
  if (node.type == AST_Block) {
    let result: String = "{\n";
    let i: i32 = 0;
    while (i < node.args.length()) {
      result = result.add("  ").add(ASTNode_codegen(node.args[i])).add("\n");
      ++i;
    }
    return result.add("}");
  }
  if (node.type == AST_IfStmt) {
    let result: String = "if (".add(ASTNode_codegen(node.cond)).add(")").add(ASTNode_codegen(node.left));
    if (node.right) result = result.add(" else ").add(ASTNode_codegen(node.right));
    return result;
  }
  if (node.type == AST_WhileStmt) {
    return "while (".add(ASTNode_codegen(node.cond)).add(")").add(ASTNode_codegen(node.left));
  }
  if (node.type == AST_ReturnStmt) {
    return "return ".add(ASTNode_codegen(node.left)).add(";");
  }
  if (node.type == AST_FunctionDecl) {
    let result: String = ASTNode_codegen(node.left).add(" ").add(node.name).add("(");
    let i: i32 = 0;
    while (i < node.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(ASTNode_codegen(node.args[i]));
      ++i;
    }
    return result.add(") ").add(ASTNode_codegen(node.right));
  }
  if (node.type == AST_InterfaceDecl) {
    let result: String = "struct ".add(node.name).add(" : virtual public Object {\n");
    let i: i32 = 0;
    while (i < node.args.length()) {
      result = result.add("  ").add(ASTNode_codegen(node.args[i])).add(";\n");
      ++i;
    }
    return result.add("};");
  }
  if (node.type == AST_Program) {
    let result: String = "#include \"src/core/core.hpp\"\n#include <cmath>\n#include <initializer_list>\n\n";

    let i: i32 = 0;
    while (i < node.args.length()) {
      if (node.args[i].type == AST_Import)
        result = result.add(ASTNode_codegen(node.args[i])).add("\n");
      ++i;
    }

    result = result.add("\n");
    i = 0;
    while (i < node.args.length()) {
      if (node.args[i].type == AST_InterfaceDecl)
        result = result.add(InterfaceDecl_declgen(node.args[i])).add("\n");
      ++i;
    }

    result = result.add("\n");
    i = 0;
    while (i < node.args.length()) {
      if (node.args[i].type == AST_FunctionDecl) {
        if (node.args[i].name === "main")
          node.args[i].name = "$main";
        result = result.add(FunctionDecl_declgen(node.args[i])).add("\n");
      }
      if (node.args[i].type == AST_Export && node.args[i].right.type == AST_FunctionDecl)
        result = result.add(FunctionDecl_declgen(node.args[i].right)).add("\n");
      ++i;
    }

    result = result.add("\n");
    i = 0;
    while (i < node.args.length()) {
      if (node.args[i].type != AST_Import)
        result = result.add(ASTNode_codegen(node.args[i])).add("\n");
      ++i;
    }

    return result;
  }
  if (node.type == AST_Import) {
    let name: String = node.name.substring(1, node.name.length() - 1);
    transpile(name.add(".tn"), ".hpp");
    return "#include \"".add(name).add(".hpp\"");
  }
  if (node.type == AST_Export) {
    return ASTNode_codegen(node.right);
  }

  return "UNKNOWN!!!";
}


let TOKEN_LET: i32 = 0;
let TOKEN_IF: i32 = 1;
let TOKEN_ELSE: i32 = 2;
let TOKEN_WHILE: i32 = 3;
let TOKEN_FUNCTION: i32 = 4;
let TOKEN_INTERFACE: i32 = 5;
let TOKEN_RETURN: i32 = 6;
let TOKEN_AS: i32 = 7;
let TOKEN_EXTENDS: i32 = 8;
let TOKEN_TRUE: i32 = 9;
let TOKEN_FALSE: i32 = 10;
let TOKEN_NULL: i32 = 11;
let TOKEN_PLUS: i32 = 12;
let TOKEN_MINUS: i32 = 13;
let TOKEN_STAR: i32 = 14;
let TOKEN_SLASH: i32 = 15;
let TOKEN_PERCENT: i32 = 16;
let TOKEN_POWER: i32 = 17;
let TOKEN_EQ: i32 = 18;
let TOKEN_NE: i32 = 19;
let TOKEN_SEQ: i32 = 20;
let TOKEN_SNE: i32 = 21;
let TOKEN_LT: i32 = 22;
let TOKEN_GT: i32 = 23;
let TOKEN_LE: i32 = 24;
let TOKEN_GE: i32 = 25;
let TOKEN_ASSIGN: i32 = 26;
let TOKEN_AND: i32 = 27;
let TOKEN_OR: i32 = 28;
let TOKEN_NOT: i32 = 29;
let TOKEN_BIT_AND: i32 = 30;
let TOKEN_BIT_OR: i32 = 31;
let TOKEN_BIT_XOR: i32 = 32;
let TOKEN_BIT_NOT: i32 = 33;
let TOKEN_LSHIFT: i32 = 34;
let TOKEN_RSHIFT: i32 = 35;
let TOKEN_INC: i32 = 36;
let TOKEN_DEC: i32 = 37;
let TOKEN_LPAREN: i32 = 38;
let TOKEN_RPAREN: i32 = 39;
let TOKEN_LBRACE: i32 = 40;
let TOKEN_RBRACE: i32 = 41;
let TOKEN_LBRACKET: i32 = 42;
let TOKEN_RBRACKET: i32 = 43;
let TOKEN_COMMA: i32 = 44;
let TOKEN_COLON: i32 = 45;
let TOKEN_SEMICOLON: i32 = 46;
let TOKEN_DOT: i32 = 47;
let TOKEN_NUMBER: i32 = 48;
let TOKEN_STRING: i32 = 49;
let TOKEN_IDENTIFIER: i32 = 50;
let TOKEN_EOF: i32 = 51;
let TOKEN_IMPORT: i32 = 52;
let TOKEN_FROM: i32 = 53;
let TOKEN_EXPORT: i32 = 54;

interface Token {
  type: i32;
  value: String;
  line: i32;
  column: i32;
}
function Token_new(type: i32, value: String, line: i32, column: i32): Token {
  let token: Token = { type: type, value: value, line: line, column: column };
  return token;
}

interface Lexer {
  input: String;
  pos: i32;
  line: i32;
  column: i32;
}
function Lexer_peek(lexer: Lexer, offset: i32): String {
  let p: i32 = lexer.pos + offset;
  if (p < lexer.input.length())
    return lexer.input[p];
  return "\0";
}
function Lexer_advance(lexer: Lexer): String {
  if (lexer.pos < lexer.input.length()) {
    let c: String = lexer.input[lexer.pos++];
    if (c === "\n") {
      lexer.line++;
      lexer.column = 1;
    } else lexer.column++;
    return c;
  }
  return "\0";
}
function Lexer_skipWhitespace(lexer: Lexer): void {
  let c: String = Lexer_peek(lexer, 0);
  while (c === " " || c === "\t" || c === "\n" || c === "\r") {
    Lexer_advance(lexer);
    c = Lexer_peek(lexer, 0);
  }
}
function Lexer_readNumber(lexer: Lexer): Token {
  let startCol: i32 = lexer.column;
  let num: String = "";
  while (Lexer_peek(lexer, 0).isInt() || Lexer_peek(lexer, 0) === ".") num = num.add(Lexer_advance(lexer));
  let token: Token = Token_new(TOKEN_NUMBER, num, lexer.line, startCol);
  return token;
}
function Lexer_readString(lexer: Lexer): Token {
  let startCol: i32 = lexer.column;
  let quote: String = Lexer_advance(lexer);
  let str: String = "".add(quote);
  while (Lexer_peek(lexer, 0) !== quote && Lexer_peek(lexer, 0) !== "\0") {
    if (Lexer_peek(lexer, 0) === "\\")
      str = str.add(Lexer_advance(lexer));
    str = str.add(Lexer_advance(lexer));
  }
  if (Lexer_peek(lexer, 0) === quote) str = str.add(Lexer_advance(lexer));
  let token: Token = Token_new(TOKEN_STRING, str, lexer.line, startCol);
  return token;
}
function Lexer_readIdentifier(lexer: Lexer): Token {
  let startCol: i32 = lexer.column;
  let id: String = "";
  while (Lexer_peek(lexer, 0).isAlNum() || Lexer_peek(lexer, 0) === "_") id = id.add(Lexer_advance(lexer));

  let keyword: i32 = TOKEN_IDENTIFIER;
  if (id === "let") keyword = TOKEN_LET;
  else if (id === "if") keyword = TOKEN_IF;
  else if (id === "else") keyword = TOKEN_ELSE;
  else if (id === "while") keyword = TOKEN_WHILE;
  else if (id === "function") keyword = TOKEN_FUNCTION;
  else if (id === "interface") keyword = TOKEN_INTERFACE;
  else if (id === "return") keyword = TOKEN_RETURN;
  else if (id === "as") keyword = TOKEN_AS;
  else if (id === "extends") keyword = TOKEN_EXTENDS;
  else if (id === "true") keyword = TOKEN_TRUE;
  else if (id === "false") keyword = TOKEN_FALSE;
  else if (id === "null") keyword = TOKEN_NULL;
  else if (id === "import") keyword = TOKEN_IMPORT;
  else if (id === "from") keyword = TOKEN_FROM;
  else if (id === "export") keyword = TOKEN_EXPORT;
  let token: Token = Token_new(keyword, id, lexer.line, startCol);
  return token;
}
function Lexer_new(input: String): Lexer {
  let lexer: Lexer = { input: input, pos: 0, line: 1, column: 1 };
  return lexer;
}
function Lexer_nextToken(lexer: Lexer): Token {
  Lexer_skipWhitespace(lexer);

  if (lexer.pos >= lexer.input.length())
    return Token_new(TOKEN_EOF, "", lexer.line, lexer.column);

  let startCol: i32 = lexer.column;
  let c: String = Lexer_peek(lexer, 0);

  if (c.isInt()) return Lexer_readNumber(lexer);
  if (c === "'" || c === "\"") return Lexer_readString(lexer);
  if (c.isAlpha() || c === "_") return Lexer_readIdentifier(lexer);

  if (c === "=" && Lexer_peek(lexer, 1) === "=") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    if (Lexer_peek(lexer, 0) === "=") {
      Lexer_advance(lexer);
      return Token_new(TOKEN_SEQ, "===", lexer.line, startCol);
    }
    return Token_new(TOKEN_EQ, "==", lexer.line, startCol);
  }
  if (c === "!" && Lexer_peek(lexer, 1) === "=") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    if (Lexer_peek(lexer, 0) === "=") {
      Lexer_advance(lexer);
      return Token_new(TOKEN_SNE, "!==", lexer.line, startCol);
    }
    return Token_new(TOKEN_NE, "!=", lexer.line, startCol);
  }
  if (c === "<" && Lexer_peek(lexer, 1) === "=") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_LE, "<=", lexer.line, startCol);
  }
  if (c === ">" && Lexer_peek(lexer, 1) === "=") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_GE, ">=", lexer.line, startCol);
  }
  if (c === "<" && Lexer_peek(lexer, 1) === "<") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_LSHIFT, "<<", lexer.line, startCol);
  }
  if (c === ">" && Lexer_peek(lexer, 1) === ">") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_RSHIFT, ">>", lexer.line, startCol);
  }
  if (c === "&" && Lexer_peek(lexer, 1) === "&") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_AND, "&&", lexer.line, startCol);
  }
  if (c === "|" && Lexer_peek(lexer, 1) === "|") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_OR, "||", lexer.line, startCol);
  }
  if (c === "+" && Lexer_peek(lexer, 1) === "+") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_INC, "++", lexer.line, startCol);
  }
  if (c === "-" && Lexer_peek(lexer, 1) === "-") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_DEC, "--", lexer.line, startCol);
  }
  if (c === "*" && Lexer_peek(lexer, 1) === "*") {
    Lexer_advance(lexer); Lexer_advance(lexer);
    return Token_new(TOKEN_POWER, "**", lexer.line, startCol);
  }

  Lexer_advance(lexer);
  if (c === "+") return Token_new(TOKEN_PLUS, "+", lexer.line, startCol);
  if (c === "-") return Token_new(TOKEN_MINUS, "-", lexer.line, startCol);
  if (c === "*") return Token_new(TOKEN_STAR, "*", lexer.line, startCol);
  if (c === "/") return Token_new(TOKEN_SLASH, "/", lexer.line, startCol);
  if (c === "%") return Token_new(TOKEN_PERCENT, "%", lexer.line, startCol);
  if (c === "=") return Token_new(TOKEN_ASSIGN, "=", lexer.line, startCol);
  if (c === "<") return Token_new(TOKEN_LT, "<", lexer.line, startCol);
  if (c === ">") return Token_new(TOKEN_GT, ">", lexer.line, startCol);
  if (c === "!") return Token_new(TOKEN_NOT, "!", lexer.line, startCol);
  if (c === "&") return Token_new(TOKEN_BIT_AND, "&", lexer.line, startCol);
  if (c === "|") return Token_new(TOKEN_BIT_OR, "|", lexer.line, startCol);
  if (c === "^") return Token_new(TOKEN_BIT_XOR, "^", lexer.line, startCol);
  if (c === "~") return Token_new(TOKEN_BIT_NOT, "~", lexer.line, startCol);
  if (c === "(") return Token_new(TOKEN_LPAREN, "(", lexer.line, startCol);
  if (c === ")") return Token_new(TOKEN_RPAREN, ")", lexer.line, startCol);
  if (c === "{") return Token_new(TOKEN_LBRACE, "{", lexer.line, startCol);
  if (c === "}") return Token_new(TOKEN_RBRACE, "}", lexer.line, startCol);
  if (c === "[") return Token_new(TOKEN_LBRACKET, "[", lexer.line, startCol);
  if (c === "]") return Token_new(TOKEN_RBRACKET, "]", lexer.line, startCol);
  if (c === ",") return Token_new(TOKEN_COMMA, ",", lexer.line, startCol);
  if (c === ":") return Token_new(TOKEN_COLON, ":", lexer.line, startCol);
  if (c === ";") return Token_new(TOKEN_SEMICOLON, ";", lexer.line, startCol);
  if (c === ".") return Token_new(TOKEN_DOT, ".", lexer.line, startCol);

  print("Unexpected character:", lexer.line, lexer.column, c);
  return Token_new(TOKEN_EOF, c, lexer.line, startCol);
}


interface Parser {
  lexer: Lexer;
  current: Token;
}
function Parser_advance(parser: Parser): void {
  parser.current = Lexer_nextToken(parser.lexer);
}
function Parser_check(parser: Parser, type: i32): boolean {
  return parser.current.type == type;
}
function Parser_match(parser: Parser, type: i32): boolean {
  if (Parser_check(parser, type)) {
    Parser_advance(parser);
    return true;
  }
  return false;
}
function Parser_expect(parser: Parser, type: i32, message: String): void {
  if (!Parser_match(parser, type)) {
    print(parser.current.line, parser.current.column, message);
    exit(1);
  }
}
function Parser_new(lexer: Lexer): Parser {
  let parser: Parser = { lexer: lexer };
  Parser_advance(parser);
  return parser;
}
function Parser_parse(parser: Parser): ASTNode {
  let statements: ASTNode[] = [];
  while (!Parser_match(parser, TOKEN_EOF))
    statements.push(Parser_parseStatement(parser));
  return Program_new(statements);
}
function Parser_parseStatement(parser: Parser): ASTNode {
  if (Parser_check(parser, TOKEN_LET)) return Parser_parseVarDecl(parser);
  if (Parser_check(parser, TOKEN_IF)) return Parser_parseIfStmt(parser);
  if (Parser_check(parser, TOKEN_WHILE)) return Parser_parseWhileStmt(parser);
  if (Parser_check(parser, TOKEN_FUNCTION)) return Parser_parseFunctionDecl(parser);
  if (Parser_check(parser, TOKEN_INTERFACE)) return Parser_parseInterfaceDecl(parser);
  if (Parser_check(parser, TOKEN_RETURN)) return Parser_parseReturnStmt(parser);
  if (Parser_check(parser, TOKEN_LBRACE)) return Parser_parseBlock(parser);
  if (Parser_check(parser, TOKEN_IMPORT)) return Parser_parseImport(parser);
  if (Parser_check(parser, TOKEN_EXPORT)) return Parser_parseExport(parser);
  return Parser_parseExprStmt(parser);
}
function Parser_parseImport(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_IMPORT, "Expected 'import' keyword");
  Parser_expect(parser, TOKEN_LBRACE, "Expected '{' after 'import' keyword");
  let specifiers: String[] = [];
  if (!Parser_check(parser, TOKEN_RBRACE)) {
    specifiers.push(parser.current.value);
    Parser_expect(parser, TOKEN_IDENTIFIER, "Expected import specifier");
    while (Parser_match(parser, TOKEN_COMMA)) {
      specifiers.push(parser.current.value);
      Parser_expect(parser, TOKEN_IDENTIFIER, "Expected import specifier");
    }
  }
  Parser_expect(parser, TOKEN_RBRACE, "Expected '}' after import specifier");
  Parser_expect(parser, TOKEN_FROM, "Expected 'from' keyword");
  let module: String = parser.current.value;
  Parser_expect(parser, TOKEN_STRING, "Expected module name");
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after import statement");
  return Import_new(module, specifiers);
}
function Parser_parseExport(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_EXPORT, "Expected 'export' keyword");
  return Export_new(Parser_parseStatement(parser));
}
function Parser_parseVarDecl(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_LET, "Expected 'let' keyword");
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected variable name");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after variable name");
  let type: ASTNode = Parser_parseType(parser);
  Parser_expect(parser, TOKEN_ASSIGN, "Expected '=' after variable type");
  let value: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after variable declaration");
  return VarDecl_new(name, type, value);
}
function Parser_parseIfStmt(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_IF, "Expected 'if' keyword");
  Parser_expect(parser, TOKEN_LPAREN, "Expected '(' after 'if' keyword");
  let cond: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after condition expression");
  let thenBranch: ASTNode = Parser_parseStatement(parser);
  let elseBranch: ASTNode = null;
  if (Parser_match(parser, TOKEN_ELSE)) elseBranch = Parser_parseStatement(parser);
  return IfStmt_new(cond, thenBranch, elseBranch);
}
function Parser_parseWhileStmt(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_WHILE, "Expected 'while' keyword");
  Parser_expect(parser, TOKEN_LPAREN, "Expected '(' after 'while' keyword");
  let cond: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after condition expression");
  let body: ASTNode = Parser_parseStatement(parser);
  return WhileStmt_new(cond, body);
}
function Parser_parseBlock(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_LBRACE, "Expected '{'");
  let statements: ASTNode[] = [];
  while (!Parser_check(parser, TOKEN_RBRACE) && !Parser_check(parser, TOKEN_EOF))
    statements.push(Parser_parseStatement(parser));
  Parser_expect(parser, TOKEN_RBRACE, "Expected '}'");
  return Block_new(statements);
}
function Parser_parseFunctionDecl(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_FUNCTION, "Expected 'function' keyword");
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected function name");
  Parser_expect(parser, TOKEN_LPAREN, "Expected '(' after function name");
  let params: ASTNode[] = [];
  if (!Parser_check(parser, TOKEN_RPAREN)) {
    params.push(Parser_parseNameType(parser));
    while (Parser_match(parser, TOKEN_COMMA)) params.push(Parser_parseNameType(parser));
  }
  Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after function parameters");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after function parameters");
  let returnType: ASTNode = Parser_parseType(parser);
  let body: ASTNode = Parser_parseBlock(parser);
  return FunctionDecl_new(name, params, returnType, body);
}
function Parser_parseNameType(parser: Parser): ASTNode {
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected identifier");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after identifier");
  let type: ASTNode = Parser_parseType(parser);
  return NameType_new(name, type);
}
function Parser_parseInterfaceDecl(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_INTERFACE, "Expected 'interface' keyword");
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected interface name");
  Parser_expect(parser, TOKEN_LBRACE, "Expected '{' after interface name");
  let members: ASTNode[] = [];
  while (!Parser_check(parser, TOKEN_RBRACE) && !Parser_check(parser, TOKEN_EOF)) {
    members.push(Parser_parseNameType(parser));
    Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after interface member");
  }
  Parser_expect(parser, TOKEN_RBRACE, "Expected '}' after interface members");
  return InterfaceDecl_new(name, members);
}
function Parser_parseReturnStmt(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_RETURN, "Expected 'return' keyword");
  let value: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after return value");
  return ReturnStmt_new(value);
}
function Parser_parseExprStmt(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after expression");
  return ExprStmt_new(expr);
}
function Parser_parseType(parser: Parser): ASTNode {
  let typeName: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected type name");
  let arrayDepth: i32 = 0;
  while (Parser_match(parser, TOKEN_LBRACKET)) {
    Parser_expect(parser, TOKEN_RBRACKET, "Expected ']' after '['");
    ++arrayDepth;
  }
  return Type_new(typeName, arrayDepth);
}
function Parser_parseExpression(parser: Parser): ASTNode {
  return Parser_parseAssignment(parser);
}
function Parser_parseAssignment(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parseLogicalOr(parser);
  if (Parser_check(parser, TOKEN_ASSIGN)) {
    Parser_advance(parser);
    let rhs: ASTNode = Parser_parseExpression(parser);
    return Assignment_new(expr, rhs);
  }
  return expr;
}
function Parser_parseLogicalOr(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseLogicalAnd(parser);
  while (Parser_match(parser, TOKEN_OR)) {
    let right: ASTNode = Parser_parseLogicalAnd(parser);
    left = BinaryOp_new("||", left, right);
  }
  return left;
}
function Parser_parseLogicalAnd(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseBitwiseOr(parser);
  while (Parser_match(parser, TOKEN_AND)) {
    let right: ASTNode = Parser_parseBitwiseOr(parser);
    left = BinaryOp_new("&&", left, right);
  }
  return left;
}
function Parser_parseBitwiseOr(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseBitwiseXor(parser);
  while (Parser_match(parser, TOKEN_BIT_OR)) {
    let right: ASTNode = Parser_parseBitwiseXor(parser);
    left = BinaryOp_new("|", left, right);
  }
  return left;
}
function Parser_parseBitwiseXor(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseBitwiseAnd(parser);
  while (Parser_match(parser, TOKEN_BIT_XOR)) {
    let right: ASTNode = Parser_parseBitwiseAnd(parser);
    left = BinaryOp_new("^", left, right);
  }
  return left;
}
function Parser_parseBitwiseAnd(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseEquality(parser);
  while (Parser_match(parser, TOKEN_BIT_AND)) {
    let right: ASTNode = Parser_parseEquality(parser);
    left = BinaryOp_new("&", left, right);
  }
  return left;
}
function Parser_parseEquality(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseRelational(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_EQ)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("==", left, right);
    } else if (Parser_match(parser, TOKEN_NE)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("!=", left, right);
    } else if (Parser_match(parser, TOKEN_SEQ)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("===", left, right);
    } else if (Parser_match(parser, TOKEN_SNE)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("!==", left, right);
    } else {
      break;
    }
  }
  return left;
}
function Parser_parseRelational(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseShift(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_LT)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new("<", left, right);
    } else if (Parser_match(parser, TOKEN_GT)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new(">", left, right);
    } else if (Parser_match(parser, TOKEN_LE)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new("<=", left, right);
    } else if (Parser_match(parser, TOKEN_GE)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new(">=", left, right);
    } else {
      break;
    }
  }
  return left;
}
function Parser_parseShift(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseAdditive(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_LSHIFT)) {
      let right: ASTNode = Parser_parseAdditive(parser);
      left = BinaryOp_new("<<", left, right);
    } else if (Parser_match(parser, TOKEN_RSHIFT)) {
      let right: ASTNode = Parser_parseAdditive(parser);
      left = BinaryOp_new(">>", left, right);
    } else {
      break;
    }
  }
  return left;
}
function Parser_parseAdditive(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseMultiplicative(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_PLUS)) {
      let right: ASTNode = Parser_parseMultiplicative(parser);
      left = BinaryOp_new("+", left, right);
    } else if (Parser_match(parser, TOKEN_MINUS)) {
      let right: ASTNode = Parser_parseMultiplicative(parser);
      left = BinaryOp_new("-", left, right);
    } else {
      break;
    }
  }
  return left;
}
function Parser_parseMultiplicative(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parsePower(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_STAR)) {
      let right: ASTNode = Parser_parsePower(parser);
      left = BinaryOp_new("*", left, right);
    } else if (Parser_match(parser, TOKEN_SLASH)) {
      let right: ASTNode = Parser_parsePower(parser);
      left = BinaryOp_new("/", left, right);
    } else if (Parser_match(parser, TOKEN_PERCENT)) {
      let right: ASTNode = Parser_parsePower(parser);
      left = BinaryOp_new("%", left, right);
    } else {
      break;
    }
  }
  return left;
}
function Parser_parsePower(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseUnary(parser);
  if (Parser_match(parser, TOKEN_POWER)) {
    let right: ASTNode = Parser_parsePower(parser);
    return BinaryOp_new("**", left, right);
  }
  return left;
}
function Parser_parseUnary(parser: Parser): ASTNode {
  if (Parser_match(parser, TOKEN_NOT)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("!", operand, true);
  }
  if (Parser_match(parser, TOKEN_BIT_NOT)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("~", operand, true);
  }
  if (Parser_match(parser, TOKEN_INC)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("++", operand, true);
  }
  if (Parser_match(parser, TOKEN_DEC)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("--", operand, true);
  }
  if (Parser_match(parser, TOKEN_PLUS)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("+", operand, true);
  }
  if (Parser_match(parser, TOKEN_MINUS)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("-", operand, true);
  }
  return Parser_parseCast(parser);
}
function Parser_parseCast(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parsePostfix(parser);
  if (Parser_match(parser, TOKEN_AS)) {
    let type: ASTNode = Parser_parseType(parser);
    return TypeCast_new(expr, type);
  }
  return expr;
}
function Parser_parsePostfix(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parseAtom(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_INC)) {
      expr = UnaryOp_new("++", expr, false);
    } else if (Parser_match(parser, TOKEN_DEC)) {
      expr = UnaryOp_new("--", expr, false);
    } else if (Parser_match(parser, TOKEN_LBRACKET)) {
      let index: ASTNode = Parser_parseExpression(parser);
      Parser_expect(parser, TOKEN_RBRACKET, "Expected ']' after index expression");
      expr = ArrayAccess_new(expr, index);
    } else if (Parser_match(parser, TOKEN_DOT)) {
      let field: String = parser.current.value;
      Parser_expect(parser, TOKEN_IDENTIFIER, "Expected field name");
      expr = FieldAccess_new(expr, field);
    } else if (Parser_match(parser, TOKEN_LPAREN)) {
      let args: ASTNode[] = [];
      if (!Parser_check(parser, TOKEN_RPAREN)) {
        args.push(Parser_parseExpression(parser));
        while (Parser_match(parser, TOKEN_COMMA)) {
          args.push(Parser_parseExpression(parser));
        }
      }
      Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after arguments");
      expr = FunctionCall_new(expr, args);
    } else {
      break;
    }
  }
  return expr;
}
function Parser_parseAtom(parser: Parser): ASTNode {
  if (Parser_check(parser, TOKEN_NUMBER)) {
    let value: String = parser.current.value;
    Parser_advance(parser);
    return NumberLiteral_new(parseFloat(value));
  }
  if (Parser_check(parser, TOKEN_STRING)) {
    let value: String = parser.current.value;
    Parser_advance(parser);
    return StringLiteral_new(value);
  }
  if (Parser_match(parser, TOKEN_TRUE)) {
    return BoolLiteral_new(true);
  }
  if (Parser_match(parser, TOKEN_FALSE)) {
    return BoolLiteral_new(false);
  }
  if (Parser_match(parser, TOKEN_NULL)) {
    return NullLiteral_new();
  }
  if (Parser_check(parser, TOKEN_IDENTIFIER)) {
    let name: String = parser.current.value;
    Parser_advance(parser);
    return Variable_new(name);
  }
  if (Parser_match(parser, TOKEN_LBRACKET)) {
    let elements: ASTNode[] = [];
    if (!Parser_check(parser, TOKEN_RBRACKET)) {
      elements.push(Parser_parseExpression(parser));
      while (Parser_match(parser, TOKEN_COMMA)) {
        elements.push(Parser_parseExpression(parser));
      }
    }
    Parser_expect(parser, TOKEN_RBRACKET, "Expected ']' after array elements");
    return ArrayLiteral_new(elements);
  }
  if (Parser_match(parser, TOKEN_LBRACE)) {
    let properties: ASTNode[] = [];
    if (!Parser_check(parser, TOKEN_RBRACE)) {
      properties.push(Parser_parseKeyVal(parser));
      while (Parser_match(parser, TOKEN_COMMA)) {
        properties.push(Parser_parseKeyVal(parser));
      }
    }
    Parser_expect(parser, TOKEN_RBRACE, "Expected '}' after object properties");
    return ObjectLiteral_new(properties);
  }
  if (Parser_match(parser, TOKEN_LPAREN)) {
    let expr: ASTNode = Parser_parseExpression(parser);
    Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after expression");
    return expr;
  }

  print("Unexpected token:", parser.current.line, parser.current.column, parser.current.value);
  exit(1);
}
function Parser_parseKeyVal(parser: Parser): ASTNode {
  let key: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected identifier");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after identifier");
  let value: ASTNode = Parser_parseExpression(parser);
  return KeyVal_new(key, value);
}


let transpiledFiles: String[] = [];
function transpile(path: String, ext: String): String {
  let needTranspilation: boolean = true;
  let i: i32 = 0;
  while (i < transpiledFiles.length()) {
    if (transpiledFiles[i] === path) {
      needTranspilation = false;
      break;
    }
    i++;
  }

  if (needTranspilation) {
    let code: File = open(path, "r");
    let lexer: Lexer = Lexer_new(code.read());
    let parser: Parser = Parser_new(lexer);
    let program: ASTNode = Parser_parse(parser);

    let transpiledPath: String = "build/".add(path.split(".")[0]).add(ext);
    let transpiledFile: File = open(transpiledPath, "w");

    if (ext === ".hpp") transpiledFile.write("#pragma once\n");
    transpiledFile.write(ASTNode_codegen(program));
    if (ext === ".cpp")
      transpiledFile.write("\nint main(int argc, char* argv[]) {\n  AutoRef<Array<AutoRef<String>>> args = AutoRef<Array<AutoRef<String>>>::make();\n  for (int i = 0; i < argc; ++i)\n    args->push(AutoRef<String>::make(argv[i]));\n  return $main(args);\n}");

    transpiledFiles.push(path);
    return transpiledPath;
  }

  return "";
}


function main(args: String[]): i32 {
  if (args.length() < 3 || args[1] !== "compile") {
    print("Usage: ".add(args[0]).add(" compile <input>"));
    return 1;
  }
  let path: String = args[2];

  system("mkdir -p build");
  system("cp -R src build/");
  let transpiledPath: String = transpile(path, ".cpp");

  let binPath: String = "dist/".add(path.split(".")[0]);
  system("mkdir -p dist");
  system("clang++-20 ".add(transpiledPath).add(" -std=c++20 -Wall -o ").add(binPath));

  return 0;
}