import { Token } from "token";

class Lexer {
  input: String;
  pos: i32;
  line: i32;
  column: i32;

  constructor(input: String) {
    this.input = input;
    this.pos = 0;
    this.line = 1;
    this.column = 1;
  }

  peek(offset: i32): String {
    let p: i32 = this.pos + offset;
    if (p < this.input.length())
      return this.input[p];
    return "\0";
  }

  advance(): String {
    if (this.pos < this.input.length()) {
      let c: String = this.input[this.pos++];
      if (c === "\n") {
        this.line++;
        this.column = 1;
      } else this.column++;
      return c;
    }
    return "\0";
  }

  skipWhitespace(): void {
    let c: String = this.peek(0);
    while (c === " " || c === "\t" || c === "\n" || c === "\r") {
      this.advance();
      c = this.peek(0);
    }
  }

  readNumber(): Token {
    let startCol: i32 = this.column;
    let num: String = "";
    while (this.peek(0).isInt() || this.peek(0) === ".") num = num.add(this.advance());
    let token: Token = new Token(TOKEN_NUMBER, num, this.line, startCol);
    return token;
  }

  readString(): Token {
    let startCol: i32 = this.column;
    let quote: String = this.advance();
    let str: String = "".add(quote);
    while (this.peek(0) !== quote && this.peek(0) !== "\0") {
      if (this.peek(0) === "\\")
        str = str.add(this.advance());
      str = str.add(this.advance());
    }
    if (this.peek(0) === quote) str = str.add(this.advance());
    let token: Token = new Token(TOKEN_STRING, str, this.line, startCol);
    return token;
  }

  readIdentifier(): Token {
    let startCol: i32 = this.column;
    let id: String = "";
    while (this.peek(0).isAlNum() || this.peek(0) === "_") id = id.add(this.advance());

    let keyword: i32 = TOKEN_IDENTIFIER;
    if (id === "let") keyword = TOKEN_LET;
    else if (id === "if") keyword = TOKEN_IF;
    else if (id === "else") keyword = TOKEN_ELSE;
    else if (id === "while") keyword = TOKEN_WHILE;
    else if (id === "function") keyword = TOKEN_FUNCTION;
    else if (id === "interface") keyword = TOKEN_INTERFACE;
    else if (id === "return") keyword = TOKEN_RETURN;
    else if (id === "as") keyword = TOKEN_AS;
    else if (id === "extends") keyword = TOKEN_EXTENDS;
    else if (id === "true") keyword = TOKEN_TRUE;
    else if (id === "false") keyword = TOKEN_FALSE;
    else if (id === "null") keyword = TOKEN_NULL;
    else if (id === "import") keyword = TOKEN_IMPORT;
    else if (id === "from") keyword = TOKEN_FROM;
    else if (id === "export") keyword = TOKEN_EXPORT;
    else if (id === "class") keyword = TOKEN_CLASS;
    else if (id === "extends") keyword = TOKEN_EXTENDS;
    else if (id === "new") keyword = TOKEN_NEW;
    let token: Token = new Token(keyword, id, this.line, startCol);
    return token;
  }

  nextToken(): Token {
    this.skipWhitespace();

    if (this.pos >= this.input.length())
      return new Token(TOKEN_EOF, "", this.line, this.column);

    let startCol: i32 = this.column;
    let c: String = this.peek(0);

    if (c.isInt()) return this.readNumber();
    if (c === "'" || c === "\"") return this.readString();
    if (c.isAlpha() || c === "_") return this.readIdentifier();

    if (c === "=" && this.peek(1) === "=") {
      this.advance(); this.advance();
      if (this.peek(0) === "=") {
        this.advance();
        return new Token(TOKEN_SEQ, "===", this.line, startCol);
      }
      return new Token(TOKEN_EQ, "==", this.line, startCol);
    }
    if (c === "!" && this.peek(1) === "=") {
      this.advance(); this.advance();
      if (this.peek(0) === "=") {
        this.advance();
        return new Token(TOKEN_SNE, "!==", this.line, startCol);
      }
      return new Token(TOKEN_NE, "!=", this.line, startCol);
    }
    if (c === "<" && this.peek(1) === "=") {
      this.advance(); this.advance();
      return new Token(TOKEN_LE, "<=", this.line, startCol);
    }
    if (c === ">" && this.peek(1) === "=") {
      this.advance(); this.advance();
      return new Token(TOKEN_GE, ">=", this.line, startCol);
    }
    if (c === "<" && this.peek(1) === "<") {
      this.advance(); this.advance();
      return new Token(TOKEN_LSHIFT, "<<", this.line, startCol);
    }
    if (c === ">" && this.peek(1) === ">") {
      this.advance(); this.advance();
      return new Token(TOKEN_RSHIFT, ">>", this.line, startCol);
    }
    if (c === "&" && this.peek(1) === "&") {
      this.advance(); this.advance();
      return new Token(TOKEN_AND, "&&", this.line, startCol);
    }
    if (c === "|" && this.peek(1) === "|") {
      this.advance(); this.advance();
      return new Token(TOKEN_OR, "||", this.line, startCol);
    }
    if (c === "+" && this.peek(1) === "+") {
      this.advance(); this.advance();
      return new Token(TOKEN_INC, "++", this.line, startCol);
    }
    if (c === "-" && this.peek(1) === "-") {
      this.advance(); this.advance();
      return new Token(TOKEN_DEC, "--", this.line, startCol);
    }
    if (c === "*" && this.peek(1) === "*") {
      this.advance(); this.advance();
      return new Token(TOKEN_POWER, "**", this.line, startCol);
    }

    this.advance();
    if (c === "+") return new Token(TOKEN_PLUS, "+", this.line, startCol);
    if (c === "-") return new Token(TOKEN_MINUS, "-", this.line, startCol);
    if (c === "*") return new Token(TOKEN_STAR, "*", this.line, startCol);
    if (c === "/") return new Token(TOKEN_SLASH, "/", this.line, startCol);
    if (c === "%") return new Token(TOKEN_PERCENT, "%", this.line, startCol);
    if (c === "=") return new Token(TOKEN_ASSIGN, "=", this.line, startCol);
    if (c === "<") return new Token(TOKEN_LT, "<", this.line, startCol);
    if (c === ">") return new Token(TOKEN_GT, ">", this.line, startCol);
    if (c === "!") return new Token(TOKEN_NOT, "!", this.line, startCol);
    if (c === "&") return new Token(TOKEN_BIT_AND, "&", this.line, startCol);
    if (c === "|") return new Token(TOKEN_BIT_OR, "|", this.line, startCol);
    if (c === "^") return new Token(TOKEN_BIT_XOR, "^", this.line, startCol);
    if (c === "~") return new Token(TOKEN_BIT_NOT, "~", this.line, startCol);
    if (c === "(") return new Token(TOKEN_LPAREN, "(", this.line, startCol);
    if (c === ")") return new Token(TOKEN_RPAREN, ")", this.line, startCol);
    if (c === "{") return new Token(TOKEN_LBRACE, "{", this.line, startCol);
    if (c === "}") return new Token(TOKEN_RBRACE, "}", this.line, startCol);
    if (c === "[") return new Token(TOKEN_LBRACKET, "[", this.line, startCol);
    if (c === "]") return new Token(TOKEN_RBRACKET, "]", this.line, startCol);
    if (c === ",") return new Token(TOKEN_COMMA, ",", this.line, startCol);
    if (c === ":") return new Token(TOKEN_COLON, ":", this.line, startCol);
    if (c === ";") return new Token(TOKEN_SEMICOLON, ";", this.line, startCol);
    if (c === ".") return new Token(TOKEN_DOT, ".", this.line, startCol);

    print("Unexpected character:", this.line, this.column, c);
    return new Token(TOKEN_EOF, c, this.line, startCol);
  }
}