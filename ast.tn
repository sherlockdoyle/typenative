class ASTNode {
  constructor(_: i32) { }
  toString(): String { return ""; }
}
class Expression extends ASTNode {
  injectedName: String;
  injectedType: Type;
}
class Statement extends ASTNode { }

class Type extends ASTNode {
  name: String;
  arrayDepth: i32;
  constructor(name: String, arrayDepth: i32) {
    this.name = name;
    this.arrayDepth = arrayDepth;
  }
  toString(): String {
    let result: String = this.name;
    let i: i32 = 0;
    while (i < this.arrayDepth) {
      result = result.add("[]");
      ++i;
    }
    return result;
  }
}

class NumberLiteral extends Expression {
  value: f64;
  constructor(value: f64) {
    this.value = value;
  }
  toString(): String {
    if (this.value == int(this.value)) return StringFrom(int(this.value));
    return StringFrom(this.value);
  }
}

class StringLiteral extends Expression {
  value: String;
  constructor(value: String) {
    this.value = value;
  }
  toString(): String {
    return this.value;
  }
}

class BoolLiteral extends Expression {
  value: boolean;
  constructor(value: boolean) {
    this.value = value;
  }
  toString(): String {
    if (this.value) return "true";
    return "false";
  }
}

class NullLiteral extends Expression {
  constructor(_: i32) { }
  toString(): String {
    return "null";
  }
}

class Variable extends Expression {
  name: String;
  constructor(name: String) {
    this.name = name;
  }
  toString(): String {
    return this.name;
  }
}

class BinaryOp extends Expression {
  op: String;
  left: Expression;
  right: Expression;
  constructor(op: String, left: Expression, right: Expression) {
    this.op = op;
    this.left = left;
    this.right = right;
  }
  toString(): String {
    return "(".add(this.left.toString()).add(" ").add(this.op).add(" ").add(this.right.toString()).add(")");
  }
}

class UnaryOp extends Expression {
  op: String;
  operand: Expression;
  prefix: boolean;
  constructor(op: String, operand: Expression, prefix: boolean) {
    this.op = op;
    this.operand = operand;
    this.prefix = prefix;
  }
  toString(): String {
    if (this.op === "new") return "(new ".add(this.operand.toString()).add(")");
    if (this.prefix) return "(".add(this.op).add(this.operand.toString()).add(")");
    return "(".add(this.operand.toString()).add(this.op).add(")");
  }
}

class Assignment extends Expression {
  lvalue: Expression;
  rvalue: Expression;
  constructor(lvalue: Expression, rvalue: Expression) {
    this.lvalue = lvalue;
    this.rvalue = rvalue;
  }
  toString(): String {
    return this.lvalue.toString().add(" = ").add(this.rvalue.toString());
  }
}

class ArrayAccess extends Expression {
  array: Expression;
  index: Expression;
  constructor(array: Expression, index: Expression) {
    this.array = array;
    this.index = index;
  }
  toString(): String {
    return this.array.toString().add("[").add(this.index.toString()).add("]");
  }
}

class FieldAccess extends Expression {
  object: Expression;
  field: String;
  constructor(object: Expression, field: String) {
    this.object = object;
    this.field = field;
  }
  toString(): String {
    return this.object.toString().add(".").add(this.field);
  }
}

class FunctionCall extends Expression {
  fun: Expression;
  args: Expression[];
  constructor(fun: Expression, args: Expression[]) {
    this.fun = fun;
    this.args = args;
  }
  toString(): String {
    let result: String = this.fun.toString().add("(");
    let i: i32 = 0;
    while (i < this.args.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(this.args[i].toString());
      ++i;
    }
    return result.add(")");
  }
}

class TypeCast extends Expression {
  expr: Expression;
  type: Type;
  constructor(expr: Expression, type: Type) {
    this.expr = expr;
    this.type = type;
  }
  toString(): String {
    return "(".add(this.expr.toString()).add(" as ").add(this.type.toString()).add(")");
  }
}

class ArrayLiteral extends Expression {
  elements: Expression[];
  constructor(elements: Expression[]) {
    this.elements = elements;
  }
  toString(): String {
    let result: String = "[";
    let i: i32 = 0;
    while (i < this.elements.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(this.elements[i].toString());
      ++i;
    }
    return result.add("]");
  }
}

class KeyVal {
  key: String;
  val: Expression;
  injectedName: String;
  constructor(key: String, val: Expression) {
    this.key = key;
    this.val = val;
  }
  toString(): String {
    return this.key.add(": ").add(this.val.toString());
  }
}
class ObjectLiteral extends Expression {
  properties: KeyVal[];
  constructor(properties: KeyVal[]) {
    this.properties = properties;
  }
  toString(): String {
    let result: String = "{";
    let i: i32 = 0;
    while (i < this.properties.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(this.properties[i].toString());
      ++i;
    }
    return result.add("}");
  }
}

class VarDecl extends Statement {
  name: String;
  type: Type;
  init: Expression;
  constructor(name: String, type: Type, init: Expression) {
    this.name = name;
    this.type = type;
    this.init = init;
  }
  toString(): String {
    return "let ".add(this.name).add(": ").add(this.type.toString()).add(" = ").add(this.init.toString()).add(";");
  }
}

class ExprStmt extends Statement {
  expr: Expression;
  constructor(expr: Expression) {
    this.expr = expr;
  }
  toString(): String {
    return this.expr.toString().add(";");
  }
}

class Block extends Statement {
  statements: Statement[];
  constructor(statements: Statement[]) {
    this.statements = statements;
  }
  toString(): String {
    let result: String = "{\n";
    let i: i32 = 0;
    while (i < this.statements.length()) {
      result = result.add("  ").add(this.statements[i].toString()).add("\n");
      ++i;
    }
    return result.add("}");
  }
}

class IfStmt extends Statement {
  cond: Expression;
  thenBranch: Statement;
  elseBranch: Statement;
  constructor(cond: Expression, thenBranch: Statement, elseBranch: Statement) {
    this.cond = cond;
    this.thenBranch = thenBranch;
    this.elseBranch = elseBranch;
  }
  toString(): String {
    let result: String = "if (".add(this.cond.toString()).add(") ").add(this.thenBranch.toString());
    if (this.elseBranch) result = result.add(" else ").add(this.elseBranch.toString());
    return result;
  }
}

class WhileStmt extends Statement {
  cond: Expression;
  body: Statement;
  constructor(cond: Expression, body: Statement) {
    this.cond = cond;
    this.body = body;
  }
  toString(): String {
    return "while (".add(this.cond.toString()).add(") ").add(this.body.toString());
  }
}

class ReturnStmt extends Statement {
  expr: Expression;
  constructor(expr: Expression) {
    this.expr = expr;
  }
  toString(): String {
    return "return ".add(this.expr.toString()).add(";");
  }
}

class NameType {
  name: String;
  type: Type;
  constructor(name: String, type: Type) {
    this.name = name;
    this.type = type;
  }
  toString(): String {
    return this.name.add(": ").add(this.type.toString());
  }
}
class FunctionDecl extends Statement {
  name: String;
  params: NameType[];
  returnType: Type;
  body: Block;
  constructor(name: String, params: NameType[], returnType: Type, body: Block) {
    this.name = name;
    this.params = params;
    this.returnType = returnType;
    this.body = body;
  }
  toString(): String {
    let result: String = "function ".add(this.name).add("(");
    let i: i32 = 0;
    while (i < this.params.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(this.params[i].toString());
      ++i;
    }
    return result.add("): ").add(this.returnType.toString()).add(" ").add(this.body.toString());
  }
}

class InterfaceDecl extends Statement {
  name: String;
  fields: NameType[];
  constructor(name: String, fields: NameType[]) {
    this.name = name;
    this.fields = fields;
  }
  toString(): String {
    let result: String = "interface ".add(this.name).add(" {\n");
    let i: i32 = 0;
    while (i < this.fields.length()) {
      result = result.add("  ").add(this.fields[i].toString()).add(";\n");
      ++i;
    }
    return result.add("}");
  }
}

class Program extends ASTNode {
  statements: Statement[];
  constructor(statements: Statement[]) {
    this.statements = statements;
  }
  toString(): String {
    let result: String = "";
    let i: i32 = 0;
    while (i < this.statements.length()) {
      result = result.add(this.statements[i].toString()).add("\n");
      ++i;
    }
    return result;
  }
}

class Import extends Statement {
  path: String;
  constructor(path: String) {
    this.path = path;
  }
  toString(): String {
    return "import {} from ".add(this.path).add(";");
  }
}

class Export extends Statement {
  statement: Statement;
  constructor(statement: Statement) {
    this.statement = statement;
  }
  toString(): String {
    return "export ".add(this.statement.toString());
  }
}

class MethodDecl extends Statement {
  name: String;
  params: NameType[];
  returnType: Type;
  body: Block;
  injectedName: String;
  constructor(name: String, params: NameType[], returnType: Type, body: Block) {
    this.name = name;
    this.params = params;
    this.returnType = returnType;
    this.body = body;
  }
  toString(): String {
    let result: String = this.name.add("(");
    let i: i32 = 0;
    while (i < this.params.length()) {
      if (i > 0) result = result.add(", ");
      result = result.add(this.params[i].toString());
      ++i;
    }
    result = result.add(")");
    if (this.returnType) result = result.add(": ").add(this.returnType.toString());
    return result.add(" ").add(this.body.toString());
  }
}
class ClassDecl extends Statement {
  name: String;
  extend: String;
  fields: NameType[];
  methods: MethodDecl[];
  constructor(name: String, extend: String, fields: NameType[], methods: MethodDecl[]) {
    this.name = name;
    this.extend = extend;
    this.fields = fields;
    this.methods = methods;
  }
  toString(): String {
    let result: String = "class ".add(this.name);
    if (this.extend) result = result.add(" extends ").add(this.extend);
    result = result.add(" {\n");
    let i: i32 = 0;
    while (i < this.fields.length()) {
      result = result.add("  ").add(this.fields[i].toString()).add(";\n");
      ++i;
    }
    i = 0;
    while (i < this.methods.length()) {
      result = result.add("  ").add(this.methods[i].toString()).add(";\n");
      ++i;
    }
    return result.add("}");
  }
}
