import { } from "ast";
import { } from "lexer";
import { } from "token";

class Parser {
  lexer: Lexer;
  current: Token;

  constructor(lexer: Lexer) {
    this.lexer = lexer;
    this.advance();
  }

  advance(): void {
    this.current = this.lexer.nextToken();
  }

  check(type: i32): boolean {
    return this.current.type == type;
  }

  match(type: i32): boolean {
    if (this.check(type)) {
      this.advance();
      return true;
    }
    return false;
  }

  expect(type: i32, message: String): void {
    if (!this.match(type)) {
      print(this.current.line, this.current.column, message);
      exit(1);
    }
  }

  parse(): Program {
    let statements: Statement[] = [];
    while (!this.match(TOKEN_EOF))
      statements.push(this.parseStatement());
    return new Program(statements);
  }

  parseStatement(): Statement {
    if (this.check(TOKEN_LET)) return this.parseVarDecl() as Statement;
    if (this.check(TOKEN_IF)) return this.parseIfStmt() as Statement;
    if (this.check(TOKEN_WHILE)) return this.parseWhileStmt() as Statement;
    if (this.check(TOKEN_FUNCTION)) return this.parseFunctionDecl() as Statement;
    if (this.check(TOKEN_INTERFACE)) return this.parseInterfaceDecl() as Statement;
    if (this.check(TOKEN_RETURN)) return this.parseReturnStmt() as Statement;
    if (this.check(TOKEN_LBRACE)) return this.parseBlock() as Statement;
    if (this.check(TOKEN_IMPORT)) return this.parseImport() as Statement;
    if (this.check(TOKEN_EXPORT)) return this.parseExport() as Statement;
    if (this.check(TOKEN_CLASS)) return this.parseClassDecl() as Statement;
    return this.parseExprStmt() as Statement;
  }

  parseClassDecl(): ClassDecl {
    this.expect(TOKEN_CLASS, "Expected 'class' keyword");
    let name: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected class name");
    let extend: String = null;
    if (this.match(TOKEN_EXTENDS)) {
      extend = this.current.value;
      this.expect(TOKEN_IDENTIFIER, "Expected class name");
    }
    this.expect(TOKEN_LBRACE, "Expected '{' after class name");
    let fields: NameType[] = [];
    while (!this.check(TOKEN_RBRACE) && !this.check(TOKEN_EOF) && this.current.value !== "constructor") {
      fields.push(this.parseNameType());
      this.expect(TOKEN_SEMICOLON, "Expected ';' after class member");
    }
    let methods: MethodDecl[] = [];
    while (!this.check(TOKEN_RBRACE) && !this.check(TOKEN_EOF)) {
      methods.push(this.parseMethodDecl());
    }
    this.expect(TOKEN_RBRACE, "Expected '}' after class members");
    return new ClassDecl(name, extend, fields, methods);
  }

  parseMethodDecl(): MethodDecl {
    let name: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected method name");
    this.expect(TOKEN_LPAREN, "Expected '(' after method name");
    let params: NameType[] = [];
    if (!this.check(TOKEN_RPAREN)) {
      params.push(this.parseNameType());
      while (this.match(TOKEN_COMMA)) params.push(this.parseNameType());
    }
    this.expect(TOKEN_RPAREN, "Expected ')' after method parameters");
    let returnType: Type = null;
    if (name !== "constructor") {
      this.expect(TOKEN_COLON, "Expected ':' after method parameters");
      returnType = this.parseType();
    }
    let body: Block = this.parseBlock();
    return new MethodDecl(name, params, returnType, body);
  }

  parseImport(): Import {
    this.expect(TOKEN_IMPORT, "Expected 'import' keyword");
    this.expect(TOKEN_LBRACE, "Expected '{' after 'import' keyword");
    let specifiers: String[] = [];
    if (!this.check(TOKEN_RBRACE)) {
      specifiers.push(this.current.value);
      this.expect(TOKEN_IDENTIFIER, "Expected import specifier");
      while (this.match(TOKEN_COMMA)) {
        specifiers.push(this.current.value);
        this.expect(TOKEN_IDENTIFIER, "Expected import specifier");
      }
    }
    this.expect(TOKEN_RBRACE, "Expected '}' after import specifier");
    this.expect(TOKEN_FROM, "Expected 'from' keyword");
    let module: String = this.current.value;
    this.expect(TOKEN_STRING, "Expected module name");
    this.expect(TOKEN_SEMICOLON, "Expected ';' after import statement");
    return new Import(module);
  }

  parseExport(): Export {
    this.expect(TOKEN_EXPORT, "Expected 'export' keyword");
    return new Export(this.parseStatement());
  }

  parseVarDecl(): VarDecl {
    this.expect(TOKEN_LET, "Expected 'let' keyword");
    let name: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected variable name");
    this.expect(TOKEN_COLON, "Expected ':' after variable name");
    let type: Type = this.parseType();
    this.expect(TOKEN_ASSIGN, "Expected '=' after variable type");
    let value: Expression = this.parseExpression();
    this.expect(TOKEN_SEMICOLON, "Expected ';' after variable declaration");
    return new VarDecl(name, type, value);
  }

  parseIfStmt(): IfStmt {
    this.expect(TOKEN_IF, "Expected 'if' keyword");
    this.expect(TOKEN_LPAREN, "Expected '(' after 'if' keyword");
    let cond: Expression = this.parseExpression();
    this.expect(TOKEN_RPAREN, "Expected ')' after condition expression");
    let thenBranch: Statement = this.parseStatement();
    let elseBranch: Statement = null;
    if (this.match(TOKEN_ELSE)) elseBranch = this.parseStatement();
    return new IfStmt(cond, thenBranch, elseBranch);
  }

  parseWhileStmt(): WhileStmt {
    this.expect(TOKEN_WHILE, "Expected 'while' keyword");
    this.expect(TOKEN_LPAREN, "Expected '(' after 'while' keyword");
    let cond: Expression = this.parseExpression();
    this.expect(TOKEN_RPAREN, "Expected ')' after condition expression");
    let body: Statement = this.parseStatement();
    return new WhileStmt(cond, body);
  }

  parseBlock(): Block {
    this.expect(TOKEN_LBRACE, "Expected '{'");
    let statements: Statement[] = [];
    while (!this.check(TOKEN_RBRACE) && !this.check(TOKEN_EOF))
      statements.push(this.parseStatement());
    this.expect(TOKEN_RBRACE, "Expected '}'");
    return new Block(statements);
  }

  parseFunctionDecl(): FunctionDecl {
    this.expect(TOKEN_FUNCTION, "Expected 'function' keyword");
    let name: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected function name");
    this.expect(TOKEN_LPAREN, "Expected '(' after function name");
    let params: NameType[] = [];
    if (!this.check(TOKEN_RPAREN)) {
      params.push(this.parseNameType());
      while (this.match(TOKEN_COMMA)) params.push(this.parseNameType());
    }
    this.expect(TOKEN_RPAREN, "Expected ')' after function parameters");
    this.expect(TOKEN_COLON, "Expected ':' after function parameters");
    let returnType: Type = this.parseType();
    let body: Block = this.parseBlock();
    return new FunctionDecl(name, params, returnType, body);
  }

  parseNameType(): NameType {
    let name: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected identifier");
    this.expect(TOKEN_COLON, "Expected ':' after identifier");
    let type: Type = this.parseType();
    return new NameType(name, type);
  }

  parseInterfaceDecl(): InterfaceDecl {
    this.expect(TOKEN_INTERFACE, "Expected 'interface' keyword");
    let name: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected interface name");
    this.expect(TOKEN_LBRACE, "Expected '{' after interface name");
    let members: NameType[] = [];
    while (!this.check(TOKEN_RBRACE) && !this.check(TOKEN_EOF)) {
      members.push(this.parseNameType());
      this.expect(TOKEN_SEMICOLON, "Expected ';' after interface member");
    }
    this.expect(TOKEN_RBRACE, "Expected '}' after interface members");
    return new InterfaceDecl(name, members);
  }

  parseReturnStmt(): ReturnStmt {
    this.expect(TOKEN_RETURN, "Expected 'return' keyword");
    let value: Expression = this.parseExpression();
    this.expect(TOKEN_SEMICOLON, "Expected ';' after return value");
    return new ReturnStmt(value);
  }

  parseExprStmt(): ExprStmt {
    let expr: Expression = this.parseExpression();
    this.expect(TOKEN_SEMICOLON, "Expected ';' after expression");
    return new ExprStmt(expr);
  }

  parseType(): Type {
    let typeName: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected type name");
    let arrayDepth: i32 = 0;
    while (this.match(TOKEN_LBRACKET)) {
      this.expect(TOKEN_RBRACKET, "Expected ']' after '['");
      ++arrayDepth;
    }
    return new Type(typeName, arrayDepth);
  }

  parseExpression(): Expression {
    return this.parseAssignment();
  }

  parseAssignment(): Expression {
    let expr: Expression = this.parseLogicalOr();
    if (this.check(TOKEN_ASSIGN)) {
      this.advance();
      let rhs: Expression = this.parseExpression();
      return (new Assignment(expr, rhs)) as Expression;
    }
    return expr;
  }

  parseLogicalOr(): Expression {
    let left: Expression = this.parseLogicalAnd();
    while (this.match(TOKEN_OR)) {
      let right: Expression = this.parseLogicalAnd();
      left = (new BinaryOp("||", left, right)) as Expression;
    }
    return left;
  }

  parseLogicalAnd(): Expression {
    let left: Expression = this.parseBitwiseOr();
    while (this.match(TOKEN_AND)) {
      let right: Expression = this.parseBitwiseOr();
      left = (new BinaryOp("&&", left, right)) as Expression;
    }
    return left;
  }

  parseBitwiseOr(): Expression {
    let left: Expression = this.parseBitwiseXor();
    while (this.match(TOKEN_BIT_OR)) {
      let right: Expression = this.parseBitwiseXor();
      left = (new BinaryOp("|", left, right)) as Expression;
    }
    return left;
  }

  parseBitwiseXor(): Expression {
    let left: Expression = this.parseBitwiseAnd();
    while (this.match(TOKEN_BIT_XOR)) {
      let right: Expression = this.parseBitwiseAnd();
      left = (new BinaryOp("^", left, right)) as Expression;
    }
    return left;
  }

  parseBitwiseAnd(): Expression {
    let left: Expression = this.parseEquality();
    while (this.match(TOKEN_BIT_AND)) {
      let right: Expression = this.parseEquality();
      left = (new BinaryOp("&", left, right)) as Expression;
    }
    return left;
  }

  parseEquality(): Expression {
    let left: Expression = this.parseRelational();
    while (true) {
      if (this.match(TOKEN_EQ)) {
        let right: Expression = this.parseRelational();
        left = (new BinaryOp("==", left, right)) as Expression;
      } else if (this.match(TOKEN_NE)) {
        let right: Expression = this.parseRelational();
        left = (new BinaryOp("!=", left, right)) as Expression;
      } else if (this.match(TOKEN_SEQ)) {
        let right: Expression = this.parseRelational();
        left = (new BinaryOp("===", left, right)) as Expression;
      } else if (this.match(TOKEN_SNE)) {
        let right: Expression = this.parseRelational();
        left = (new BinaryOp("!==", left, right)) as Expression;
      } else {
        break;
      }
    }
    return left;
  }

  parseRelational(): Expression {
    let left: Expression = this.parseShift();
    while (true) {
      if (this.match(TOKEN_LT)) {
        let right: Expression = this.parseShift();
        left = (new BinaryOp("<", left, right)) as Expression;
      } else if (this.match(TOKEN_GT)) {
        let right: Expression = this.parseShift();
        left = (new BinaryOp(">", left, right)) as Expression;
      } else if (this.match(TOKEN_LE)) {
        let right: Expression = this.parseShift();
        left = (new BinaryOp("<=", left, right)) as Expression;
      } else if (this.match(TOKEN_GE)) {
        let right: Expression = this.parseShift();
        left = (new BinaryOp(">=", left, right)) as Expression;
      } else {
        break;
      }
    }
    return left;
  }

  parseShift(): Expression {
    let left: Expression = this.parseAdditive();
    while (true) {
      if (this.match(TOKEN_LSHIFT)) {
        let right: Expression = this.parseAdditive();
        left = (new BinaryOp("<<", left, right)) as Expression;
      } else if (this.match(TOKEN_RSHIFT)) {
        let right: Expression = this.parseAdditive();
        left = (new BinaryOp(">>", left, right)) as Expression;
      } else {
        break;
      }
    }
    return left;
  }

  parseAdditive(): Expression {
    let left: Expression = this.parseMultiplicative();
    while (true) {
      if (this.match(TOKEN_PLUS)) {
        let right: Expression = this.parseMultiplicative();
        left = (new BinaryOp("+", left, right)) as Expression;
      } else if (this.match(TOKEN_MINUS)) {
        let right: Expression = this.parseMultiplicative();
        left = (new BinaryOp("-", left, right)) as Expression;
      } else {
        break;
      }
    }
    return left;
  }

  parseMultiplicative(): Expression {
    let left: Expression = this.parsePower();
    while (true) {
      if (this.match(TOKEN_STAR)) {
        let right: Expression = this.parsePower();
        left = (new BinaryOp("*", left, right)) as Expression;
      } else if (this.match(TOKEN_SLASH)) {
        let right: Expression = this.parsePower();
        left = (new BinaryOp("/", left, right)) as Expression;
      } else if (this.match(TOKEN_PERCENT)) {
        let right: Expression = this.parsePower();
        left = (new BinaryOp("%", left, right)) as Expression;
      } else {
        break;
      }
    }
    return left;
  }

  parsePower(): Expression {
    let left: Expression = this.parseUnary();
    if (this.match(TOKEN_POWER)) {
      let right: Expression = this.parsePower();
      return (new BinaryOp("**", left, right)) as Expression;
    }
    return left;
  }

  parseUnary(): Expression {
    if (this.match(TOKEN_NOT)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("!", operand, true)) as Expression;
    }
    if (this.match(TOKEN_BIT_NOT)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("~", operand, true)) as Expression;
    }
    if (this.match(TOKEN_INC)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("++", operand, true)) as Expression;
    }
    if (this.match(TOKEN_DEC)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("--", operand, true)) as Expression;
    }
    if (this.match(TOKEN_PLUS)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("+", operand, true)) as Expression;
    }
    if (this.match(TOKEN_MINUS)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("-", operand, true)) as Expression;
    }
    if (this.match(TOKEN_NEW)) {
      let operand: Expression = this.parseUnary();
      return (new UnaryOp("new", operand, true)) as Expression;
    }
    return this.parseCast();
  }

  parseCast(): Expression {
    let expr: Expression = this.parsePostfix();
    if (this.match(TOKEN_AS)) {
      let type: Type = this.parseType();
      return (new TypeCast(expr, type)) as Expression;
    }
    return expr;
  }

  parsePostfix(): Expression {
    let expr: Expression = this.parseAtom();
    while (true) {
      if (this.match(TOKEN_INC)) {
        expr = (new UnaryOp("++", expr, false)) as Expression;
      } else if (this.match(TOKEN_DEC)) {
        expr = (new UnaryOp("--", expr, false)) as Expression;
      } else if (this.match(TOKEN_LBRACKET)) {
        let index: Expression = this.parseExpression();
        this.expect(TOKEN_RBRACKET, "Expected ']' after index expression");
        expr = (new ArrayAccess(expr, index)) as Expression;
      } else if (this.match(TOKEN_DOT)) {
        let field: String = this.current.value;
        this.expect(TOKEN_IDENTIFIER, "Expected field name");
        expr = (new FieldAccess(expr, field)) as Expression;
      } else if (this.match(TOKEN_LPAREN)) {
        let args: Expression[] = [];
        if (!this.check(TOKEN_RPAREN)) {
          args.push(this.parseExpression());
          while (this.match(TOKEN_COMMA)) {
            args.push(this.parseExpression());
          }
        }
        this.expect(TOKEN_RPAREN, "Expected ')' after arguments");
        expr = (new FunctionCall(expr, args)) as Expression;
      } else {
        break;
      }
    }
    return expr;
  }

  parseAtom(): Expression {
    if (this.check(TOKEN_NUMBER)) {
      let value: String = this.current.value;
      this.advance();
      return (new NumberLiteral(parseFloat(value))) as Expression;
    }
    if (this.check(TOKEN_STRING)) {
      let value: String = this.current.value;
      this.advance();
      return (new StringLiteral(value)) as Expression;
    }
    if (this.match(TOKEN_TRUE)) {
      return (new BoolLiteral(true)) as Expression;
    }
    if (this.match(TOKEN_FALSE)) {
      return (new BoolLiteral(false)) as Expression;
    }
    if (this.match(TOKEN_NULL)) {
      return (new NullLiteral()) as Expression;
    }
    if (this.check(TOKEN_IDENTIFIER)) {
      let name: String = this.current.value;
      this.advance();
      return (new Variable(name)) as Expression;
    }
    if (this.match(TOKEN_LBRACKET)) {
      let elements: Expression[] = [];
      if (!this.check(TOKEN_RBRACKET)) {
        elements.push(this.parseExpression());
        while (this.match(TOKEN_COMMA)) {
          elements.push(this.parseExpression());
        }
      }
      this.expect(TOKEN_RBRACKET, "Expected ']' after array elements");
      return (new ArrayLiteral(elements)) as Expression;
    }
    if (this.match(TOKEN_LBRACE)) {
      let properties: KeyVal[] = [];
      if (!this.check(TOKEN_RBRACE)) {
        properties.push(this.parseKeyVal());
        while (this.match(TOKEN_COMMA)) {
          properties.push(this.parseKeyVal());
        }
      }
      this.expect(TOKEN_RBRACE, "Expected '}' after object properties");
      return (new ObjectLiteral(properties)) as Expression;
    }
    if (this.match(TOKEN_LPAREN)) {
      let expr: Expression = this.parseExpression();
      this.expect(TOKEN_RPAREN, "Expected ')' after expression");
      return expr;
    }

    print("Unexpected token:", this.current.line, this.current.column, this.current.value);
    exit(1);
  }

  parseKeyVal(): KeyVal {
    let key: String = this.current.value;
    this.expect(TOKEN_IDENTIFIER, "Expected identifier");
    this.expect(TOKEN_COLON, "Expected ':' after identifier");
    let value: Expression = this.parseExpression();
    return new KeyVal(key, value);
  }
}