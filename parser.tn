import { } from "ast";
import { } from "lexer";
import { } from "token";

interface Parser {
  lexer: Lexer;
  current: Token;
}

function Parser_advance(parser: Parser): void {
  parser.current = Lexer_nextToken(parser.lexer);
}

function Parser_check(parser: Parser, type: i32): boolean {
  return parser.current.type == type;
}

function Parser_match(parser: Parser, type: i32): boolean {
  if (Parser_check(parser, type)) {
    Parser_advance(parser);
    return true;
  }
  return false;
}

function Parser_expect(parser: Parser, type: i32, message: String): void {
  if (!Parser_match(parser, type)) {
    print(parser.current.line, parser.current.column, message);
    exit(1);
  }
}

function Parser_new(lexer: Lexer): Parser {
  let parser: Parser = { lexer: lexer };
  Parser_advance(parser);
  return parser;
}

function Parser_parse(parser: Parser): ASTNode {
  let statements: ASTNode[] = [];
  while (!Parser_match(parser, TOKEN_EOF))
    statements.push(Parser_parseStatement(parser));
  return Program_new(statements);
}

function Parser_parseStatement(parser: Parser): ASTNode {
  if (Parser_check(parser, TOKEN_LET)) return Parser_parseVarDecl(parser);
  if (Parser_check(parser, TOKEN_IF)) return Parser_parseIfStmt(parser);
  if (Parser_check(parser, TOKEN_WHILE)) return Parser_parseWhileStmt(parser);
  if (Parser_check(parser, TOKEN_FUNCTION)) return Parser_parseFunctionDecl(parser);
  if (Parser_check(parser, TOKEN_INTERFACE)) return Parser_parseInterfaceDecl(parser);
  if (Parser_check(parser, TOKEN_RETURN)) return Parser_parseReturnStmt(parser);
  if (Parser_check(parser, TOKEN_LBRACE)) return Parser_parseBlock(parser);
  if (Parser_check(parser, TOKEN_IMPORT)) return Parser_parseImport(parser);
  if (Parser_check(parser, TOKEN_EXPORT)) return Parser_parseExport(parser);
  return Parser_parseExprStmt(parser);
}

function Parser_parseImport(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_IMPORT, "Expected 'import' keyword");
  Parser_expect(parser, TOKEN_LBRACE, "Expected '{' after 'import' keyword");
  let specifiers: String[] = [];
  if (!Parser_check(parser, TOKEN_RBRACE)) {
    specifiers.push(parser.current.value);
    Parser_expect(parser, TOKEN_IDENTIFIER, "Expected import specifier");
    while (Parser_match(parser, TOKEN_COMMA)) {
      specifiers.push(parser.current.value);
      Parser_expect(parser, TOKEN_IDENTIFIER, "Expected import specifier");
    }
  }
  Parser_expect(parser, TOKEN_RBRACE, "Expected '}' after import specifier");
  Parser_expect(parser, TOKEN_FROM, "Expected 'from' keyword");
  let module: String = parser.current.value;
  Parser_expect(parser, TOKEN_STRING, "Expected module name");
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after import statement");
  return Import_new(module, specifiers);
}

function Parser_parseExport(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_EXPORT, "Expected 'export' keyword");
  return Export_new(Parser_parseStatement(parser));
}

function Parser_parseVarDecl(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_LET, "Expected 'let' keyword");
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected variable name");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after variable name");
  let type: ASTNode = Parser_parseType(parser);
  Parser_expect(parser, TOKEN_ASSIGN, "Expected '=' after variable type");
  let value: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after variable declaration");
  return VarDecl_new(name, type, value);
}

function Parser_parseIfStmt(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_IF, "Expected 'if' keyword");
  Parser_expect(parser, TOKEN_LPAREN, "Expected '(' after 'if' keyword");
  let cond: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after condition expression");
  let thenBranch: ASTNode = Parser_parseStatement(parser);
  let elseBranch: ASTNode = null;
  if (Parser_match(parser, TOKEN_ELSE)) elseBranch = Parser_parseStatement(parser);
  return IfStmt_new(cond, thenBranch, elseBranch);
}

function Parser_parseWhileStmt(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_WHILE, "Expected 'while' keyword");
  Parser_expect(parser, TOKEN_LPAREN, "Expected '(' after 'while' keyword");
  let cond: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after condition expression");
  let body: ASTNode = Parser_parseStatement(parser);
  return WhileStmt_new(cond, body);
}

function Parser_parseBlock(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_LBRACE, "Expected '{'");
  let statements: ASTNode[] = [];
  while (!Parser_check(parser, TOKEN_RBRACE) && !Parser_check(parser, TOKEN_EOF))
    statements.push(Parser_parseStatement(parser));
  Parser_expect(parser, TOKEN_RBRACE, "Expected '}'");
  return Block_new(statements);
}

function Parser_parseFunctionDecl(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_FUNCTION, "Expected 'function' keyword");
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected function name");
  Parser_expect(parser, TOKEN_LPAREN, "Expected '(' after function name");
  let params: ASTNode[] = [];
  if (!Parser_check(parser, TOKEN_RPAREN)) {
    params.push(Parser_parseNameType(parser));
    while (Parser_match(parser, TOKEN_COMMA)) params.push(Parser_parseNameType(parser));
  }
  Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after function parameters");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after function parameters");
  let returnType: ASTNode = Parser_parseType(parser);
  let body: ASTNode = Parser_parseBlock(parser);
  return FunctionDecl_new(name, params, returnType, body);
}

function Parser_parseNameType(parser: Parser): ASTNode {
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected identifier");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after identifier");
  let type: ASTNode = Parser_parseType(parser);
  return NameType_new(name, type);
}

function Parser_parseInterfaceDecl(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_INTERFACE, "Expected 'interface' keyword");
  let name: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected interface name");
  Parser_expect(parser, TOKEN_LBRACE, "Expected '{' after interface name");
  let members: ASTNode[] = [];
  while (!Parser_check(parser, TOKEN_RBRACE) && !Parser_check(parser, TOKEN_EOF)) {
    members.push(Parser_parseNameType(parser));
    Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after interface member");
  }
  Parser_expect(parser, TOKEN_RBRACE, "Expected '}' after interface members");
  return InterfaceDecl_new(name, members);
}

function Parser_parseReturnStmt(parser: Parser): ASTNode {
  Parser_expect(parser, TOKEN_RETURN, "Expected 'return' keyword");
  let value: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after return value");
  return ReturnStmt_new(value);
}

function Parser_parseExprStmt(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parseExpression(parser);
  Parser_expect(parser, TOKEN_SEMICOLON, "Expected ';' after expression");
  return ExprStmt_new(expr);
}

function Parser_parseType(parser: Parser): ASTNode {
  let typeName: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected type name");
  let arrayDepth: i32 = 0;
  while (Parser_match(parser, TOKEN_LBRACKET)) {
    Parser_expect(parser, TOKEN_RBRACKET, "Expected ']' after '['");
    ++arrayDepth;
  }
  return Type_new(typeName, arrayDepth);
}

function Parser_parseExpression(parser: Parser): ASTNode {
  return Parser_parseAssignment(parser);
}

function Parser_parseAssignment(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parseLogicalOr(parser);
  if (Parser_check(parser, TOKEN_ASSIGN)) {
    Parser_advance(parser);
    let rhs: ASTNode = Parser_parseExpression(parser);
    return Assignment_new(expr, rhs);
  }
  return expr;
}

function Parser_parseLogicalOr(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseLogicalAnd(parser);
  while (Parser_match(parser, TOKEN_OR)) {
    let right: ASTNode = Parser_parseLogicalAnd(parser);
    left = BinaryOp_new("||", left, right);
  }
  return left;
}

function Parser_parseLogicalAnd(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseBitwiseOr(parser);
  while (Parser_match(parser, TOKEN_AND)) {
    let right: ASTNode = Parser_parseBitwiseOr(parser);
    left = BinaryOp_new("&&", left, right);
  }
  return left;
}

function Parser_parseBitwiseOr(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseBitwiseXor(parser);
  while (Parser_match(parser, TOKEN_BIT_OR)) {
    let right: ASTNode = Parser_parseBitwiseXor(parser);
    left = BinaryOp_new("|", left, right);
  }
  return left;
}

function Parser_parseBitwiseXor(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseBitwiseAnd(parser);
  while (Parser_match(parser, TOKEN_BIT_XOR)) {
    let right: ASTNode = Parser_parseBitwiseAnd(parser);
    left = BinaryOp_new("^", left, right);
  }
  return left;
}

function Parser_parseBitwiseAnd(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseEquality(parser);
  while (Parser_match(parser, TOKEN_BIT_AND)) {
    let right: ASTNode = Parser_parseEquality(parser);
    left = BinaryOp_new("&", left, right);
  }
  return left;
}

function Parser_parseEquality(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseRelational(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_EQ)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("==", left, right);
    } else if (Parser_match(parser, TOKEN_NE)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("!=", left, right);
    } else if (Parser_match(parser, TOKEN_SEQ)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("===", left, right);
    } else if (Parser_match(parser, TOKEN_SNE)) {
      let right: ASTNode = Parser_parseRelational(parser);
      left = BinaryOp_new("!==", left, right);
    } else {
      break;
    }
  }
  return left;
}

function Parser_parseRelational(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseShift(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_LT)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new("<", left, right);
    } else if (Parser_match(parser, TOKEN_GT)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new(">", left, right);
    } else if (Parser_match(parser, TOKEN_LE)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new("<=", left, right);
    } else if (Parser_match(parser, TOKEN_GE)) {
      let right: ASTNode = Parser_parseShift(parser);
      left = BinaryOp_new(">=", left, right);
    } else {
      break;
    }
  }
  return left;
}

function Parser_parseShift(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseAdditive(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_LSHIFT)) {
      let right: ASTNode = Parser_parseAdditive(parser);
      left = BinaryOp_new("<<", left, right);
    } else if (Parser_match(parser, TOKEN_RSHIFT)) {
      let right: ASTNode = Parser_parseAdditive(parser);
      left = BinaryOp_new(">>", left, right);
    } else {
      break;
    }
  }
  return left;
}

function Parser_parseAdditive(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseMultiplicative(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_PLUS)) {
      let right: ASTNode = Parser_parseMultiplicative(parser);
      left = BinaryOp_new("+", left, right);
    } else if (Parser_match(parser, TOKEN_MINUS)) {
      let right: ASTNode = Parser_parseMultiplicative(parser);
      left = BinaryOp_new("-", left, right);
    } else {
      break;
    }
  }
  return left;
}

function Parser_parseMultiplicative(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parsePower(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_STAR)) {
      let right: ASTNode = Parser_parsePower(parser);
      left = BinaryOp_new("*", left, right);
    } else if (Parser_match(parser, TOKEN_SLASH)) {
      let right: ASTNode = Parser_parsePower(parser);
      left = BinaryOp_new("/", left, right);
    } else if (Parser_match(parser, TOKEN_PERCENT)) {
      let right: ASTNode = Parser_parsePower(parser);
      left = BinaryOp_new("%", left, right);
    } else {
      break;
    }
  }
  return left;
}

function Parser_parsePower(parser: Parser): ASTNode {
  let left: ASTNode = Parser_parseUnary(parser);
  if (Parser_match(parser, TOKEN_POWER)) {
    let right: ASTNode = Parser_parsePower(parser);
    return BinaryOp_new("**", left, right);
  }
  return left;
}

function Parser_parseUnary(parser: Parser): ASTNode {
  if (Parser_match(parser, TOKEN_NOT)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("!", operand, true);
  }
  if (Parser_match(parser, TOKEN_BIT_NOT)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("~", operand, true);
  }
  if (Parser_match(parser, TOKEN_INC)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("++", operand, true);
  }
  if (Parser_match(parser, TOKEN_DEC)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("--", operand, true);
  }
  if (Parser_match(parser, TOKEN_PLUS)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("+", operand, true);
  }
  if (Parser_match(parser, TOKEN_MINUS)) {
    let operand: ASTNode = Parser_parseUnary(parser);
    return UnaryOp_new("-", operand, true);
  }
  return Parser_parseCast(parser);
}

function Parser_parseCast(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parsePostfix(parser);
  if (Parser_match(parser, TOKEN_AS)) {
    let type: ASTNode = Parser_parseType(parser);
    return TypeCast_new(expr, type);
  }
  return expr;
}

function Parser_parsePostfix(parser: Parser): ASTNode {
  let expr: ASTNode = Parser_parseAtom(parser);
  while (true) {
    if (Parser_match(parser, TOKEN_INC)) {
      expr = UnaryOp_new("++", expr, false);
    } else if (Parser_match(parser, TOKEN_DEC)) {
      expr = UnaryOp_new("--", expr, false);
    } else if (Parser_match(parser, TOKEN_LBRACKET)) {
      let index: ASTNode = Parser_parseExpression(parser);
      Parser_expect(parser, TOKEN_RBRACKET, "Expected ']' after index expression");
      expr = ArrayAccess_new(expr, index);
    } else if (Parser_match(parser, TOKEN_DOT)) {
      let field: String = parser.current.value;
      Parser_expect(parser, TOKEN_IDENTIFIER, "Expected field name");
      expr = FieldAccess_new(expr, field);
    } else if (Parser_match(parser, TOKEN_LPAREN)) {
      let args: ASTNode[] = [];
      if (!Parser_check(parser, TOKEN_RPAREN)) {
        args.push(Parser_parseExpression(parser));
        while (Parser_match(parser, TOKEN_COMMA)) {
          args.push(Parser_parseExpression(parser));
        }
      }
      Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after arguments");
      expr = FunctionCall_new(expr, args);
    } else {
      break;
    }
  }
  return expr;
}

function Parser_parseAtom(parser: Parser): ASTNode {
  if (Parser_check(parser, TOKEN_NUMBER)) {
    let value: String = parser.current.value;
    Parser_advance(parser);
    return NumberLiteral_new(parseFloat(value));
  }
  if (Parser_check(parser, TOKEN_STRING)) {
    let value: String = parser.current.value;
    Parser_advance(parser);
    return StringLiteral_new(value);
  }
  if (Parser_match(parser, TOKEN_TRUE)) {
    return BoolLiteral_new(true);
  }
  if (Parser_match(parser, TOKEN_FALSE)) {
    return BoolLiteral_new(false);
  }
  if (Parser_match(parser, TOKEN_NULL)) {
    return NullLiteral_new();
  }
  if (Parser_check(parser, TOKEN_IDENTIFIER)) {
    let name: String = parser.current.value;
    Parser_advance(parser);
    return Variable_new(name);
  }
  if (Parser_match(parser, TOKEN_LBRACKET)) {
    let elements: ASTNode[] = [];
    if (!Parser_check(parser, TOKEN_RBRACKET)) {
      elements.push(Parser_parseExpression(parser));
      while (Parser_match(parser, TOKEN_COMMA)) {
        elements.push(Parser_parseExpression(parser));
      }
    }
    Parser_expect(parser, TOKEN_RBRACKET, "Expected ']' after array elements");
    return ArrayLiteral_new(elements);
  }
  if (Parser_match(parser, TOKEN_LBRACE)) {
    let properties: ASTNode[] = [];
    if (!Parser_check(parser, TOKEN_RBRACE)) {
      properties.push(Parser_parseKeyVal(parser));
      while (Parser_match(parser, TOKEN_COMMA)) {
        properties.push(Parser_parseKeyVal(parser));
      }
    }
    Parser_expect(parser, TOKEN_RBRACE, "Expected '}' after object properties");
    return ObjectLiteral_new(properties);
  }
  if (Parser_match(parser, TOKEN_LPAREN)) {
    let expr: ASTNode = Parser_parseExpression(parser);
    Parser_expect(parser, TOKEN_RPAREN, "Expected ')' after expression");
    return expr;
  }

  print("Unexpected token:", parser.current.line, parser.current.column, parser.current.value);
  exit(1);
}

function Parser_parseKeyVal(parser: Parser): ASTNode {
  let key: String = parser.current.value;
  Parser_expect(parser, TOKEN_IDENTIFIER, "Expected identifier");
  Parser_expect(parser, TOKEN_COLON, "Expected ':' after identifier");
  let value: ASTNode = Parser_parseExpression(parser);
  return KeyVal_new(key, value);
}